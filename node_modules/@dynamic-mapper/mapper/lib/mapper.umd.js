(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.mapper = {}));
}(this, (function (exports) { 'use strict';

    var ResolutionContext = /** @class */ (function () {
        function ResolutionContext(defaultContext) {
            this.defaultContext = defaultContext;
        }
        ResolutionContext.prototype.map = function (pair, source, destination) {
            return this.defaultContext.map(pair, source, destination);
        };
        return ResolutionContext;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    function isType(v) {
        return typeof v === 'function';
    }
    function isSymbol(v) {
        return typeof v === 'symbol' || typeof v === 'object' && Object.prototype.toString.call(v) === '[object Symbol]';
    }
    var MappingPair = /** @class */ (function () {
        function MappingPair(source, destination) {
            if (source === void 0) { source = Symbol(); }
            if (destination === void 0) { destination = Symbol(); }
            this.source = source;
            this.destination = destination;
        }
        MappingPair.prototype.toString = function () {
            return "[MappingPair<" + this.source.toString() + ", " + this.destination.toString() + ">]";
        };
        return MappingPair;
    }());
    var ArrayToObjectMappingPair = /** @class */ (function (_super) {
        __extends(ArrayToObjectMappingPair, _super);
        function ArrayToObjectMappingPair() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ArrayToObjectMappingPair;
    }(MappingPair));

    var Mapper = /** @class */ (function () {
        function Mapper(configuration) {
            this.configuration = configuration;
            this.defaultContext = new ResolutionContext(this);
        }
        Mapper.prototype.map = function (pair, source, destination) {
            var _this = this;
            var func = this.configuration.getMapperFunction(pair);
            if (pair instanceof ArrayToObjectMappingPair) {
                return this.mapArrayToObject(pair, source, destination);
            }
            return Array.isArray(source) ? source.map(function (s) { return func(s, destination, _this.defaultContext); }) :
                func(source, destination, this.defaultContext);
        };
        Mapper.prototype.mapArrayToObject = function (pair, sources, destination) {
            var func = this.configuration.getMapperFunction(pair);
            return func(sources, destination, this.defaultContext);
        };
        return Mapper;
    }());

    var SourceMemberConfig = /** @class */ (function () {
        function SourceMemberConfig(sourceMember) {
            this.sourceMember = sourceMember;
        }
        SourceMemberConfig.prototype.ignore = function () {
            this._ignored = true;
        };
        SourceMemberConfig.prototype.isIgnored = function () {
            return this._ignored;
        };
        return SourceMemberConfig;
    }());

    var PropertyMap = /** @class */ (function () {
        function PropertyMap(destinationMember, typeMap, inheritedMappedProperty) {
            this.destinationMember = destinationMember;
            this.typeMap = typeMap;
            this._memberChain = [];
            this._valueTransformers = [];
            if (inheritedMappedProperty) {
                this.applyInheritedPropertyMap(inheritedMappedProperty);
            }
        }
        Object.defineProperty(PropertyMap.prototype, "sourceMembers", {
            get: function () { return this._memberChain; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyMap.prototype, "valueTransformers", {
            get: function () { return this._valueTransformers; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyMap.prototype, "isMapped", {
            get: function () { return this.ignored || this.canResolveValue; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyMap.prototype, "canResolveValue", {
            get: function () { return !this.ignored; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyMap.prototype, "isResolveConfigured", {
            get: function () { return this.customMappingFunction != null; },
            enumerable: true,
            configurable: true
        });
        PropertyMap.prototype.chainMembers = function (members) {
            var _this = this;
            members.forEach(function (x) { return _this._memberChain.push(x); });
        };
        PropertyMap.prototype.mapFrom = function (mappingFunction) {
            this.customMappingFunction = mappingFunction;
            this.ignored = false;
        };
        PropertyMap.prototype.mapFromUsing = function (mappingFunction, pair) {
            this.mapFrom(mappingFunction);
            this.pair = pair;
        };
        PropertyMap.prototype.addValueTransformation = function (transformer) {
            this._valueTransformers.push(transformer);
        };
        PropertyMap.prototype.applyInheritedPropertyMap = function (inheritedMappedProperty) {
            var _a;
            if (inheritedMappedProperty.ignored && !this.isResolveConfigured) {
                this.ignored = true;
            }
            this.customMappingFunction = this.customMappingFunction || inheritedMappedProperty.customMappingFunction;
            this.pair = this.pair || inheritedMappedProperty.pair;
            this.condition = this.condition || inheritedMappedProperty.condition;
            this.precondition = this.precondition || inheritedMappedProperty.precondition;
            this.nullSubstitute = this.nullSubstitute || inheritedMappedProperty.nullSubstitute;
            (_a = this._valueTransformers).push.apply(_a, inheritedMappedProperty.valueTransformers);
            this._memberChain = this._memberChain.length === 0 ? inheritedMappedProperty._memberChain : this._memberChain;
        };
        return PropertyMap;
    }());

    var TypeMapPlanBuilder = /** @class */ (function () {
        function TypeMapPlanBuilder(configurationProvider, typeMap) {
            this.configurationProvider = configurationProvider;
            this.typeMap = typeMap;
        }
        TypeMapPlanBuilder.prototype.createMapper = function () {
            var _this = this;
            var customConverter = this.typeMap.customMapFunction;
            if (customConverter) {
                return customConverter;
            }
            var destinationFunc = this.createDestinationFunc();
            var assignmentFunc = this.createAssignment();
            var transformerFunc = this.createTransformerFn(__spreadArrays(this.typeMap.valueTransformers, this.typeMap.profile.valueTransformers));
            return function (source, destination, context) {
                var subtypeMap = _this.typeMap.subtypeMaps.find(function (map) { return map.condition(source); });
                if (subtypeMap) {
                    // Switch mapping to a subtype mapper.
                    return context.map(subtypeMap.pair, source, destination);
                }
                var dest = destination ? destination : destinationFunc(source);
                _this.typeMap.beforeMapFunctions.forEach(function (fn) { return fn(source, dest, context); });
                if (_this.typeMap.implicitAutoMapping && source) {
                    for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
                        var key = _a[_i];
                        var sourceMap = _this.typeMap.sourceMemberConfigs.get(key);
                        if (sourceMap === null || sourceMap === void 0 ? void 0 : sourceMap.isIgnored()) {
                            continue;
                        }
                        var propertyMap = _this.typeMap.propertyMaps.get(key);
                        if (propertyMap) {
                            if (propertyMap.canResolveValue && !propertyMap.isResolveConfigured) {
                                _this.tryPropertyMap(propertyMap, propertyMap.destinationMember)(source, dest, context);
                            }
                        }
                        else {
                            dest[key] = transformerFunc(source[key]);
                        }
                    }
                }
                for (var _b = 0, assignmentFunc_1 = assignmentFunc; _b < assignmentFunc_1.length; _b++) {
                    var fn = assignmentFunc_1[_b];
                    fn(source, dest, context);
                }
                _this.typeMap.afterMapFunctions.forEach(function (fn) { return fn(source, dest, context); });
                return dest;
            };
        };
        TypeMapPlanBuilder.prototype.createDestinationFunc = function () {
            var _this = this;
            if (this.typeMap.customCtorFunction) {
                return this.typeMap.customCtorFunction;
            }
            else if (isType(this.typeMap.destinationType)) {
                return function () { return new _this.typeMap.destinationType(); };
            }
            else if (isSymbol(this.typeMap.destinationType)) {
                return function () { return ({}); };
            }
            throw new Error('Unable to create destination type');
        };
        TypeMapPlanBuilder.prototype.createAssignment = function () {
            var _this = this;
            var assignmentFns = [];
            this.typeMap.propertyMaps.forEach(function (propertyMap) {
                if (propertyMap.canResolveValue) {
                    var property = _this.tryPropertyMap(propertyMap, propertyMap.destinationMember);
                    assignmentFns.push(property);
                }
            });
            return assignmentFns;
        };
        TypeMapPlanBuilder.prototype.tryPropertyMap = function (memberMap, destinationMember) {
            var setter = function (destination, value) { return destination[destinationMember] = value; };
            var resolvers = [this.buildValueResolver(memberMap)];
            if (memberMap.pair) {
                resolvers.push(this.mapFunction(memberMap.pair, destinationMember));
            }
            var transformer = this.createTransformerFn(__spreadArrays(memberMap.valueTransformers, this.typeMap.valueTransformers, this.typeMap.profile.valueTransformers));
            var valueResolver = function (source, destination, context) {
                return __spreadArrays(resolvers, [transformer]).reduce(function (prev, curr) { return curr(prev, destination, context); }, source);
            };
            return function (source, destination, context) {
                if (memberMap.precondition && !memberMap.precondition(source, destination)) {
                    return;
                }
                var resolvedValue = valueResolver(source, destination, context);
                if (memberMap.condition && !memberMap.condition(source, destination)) {
                    return;
                }
                setter(destination, resolvedValue);
            };
        };
        TypeMapPlanBuilder.prototype.createTransformerFn = function (transformers) {
            return function (source) { return transformers.reduce(function (prev, curr) { return curr(prev); }, source); };
        };
        TypeMapPlanBuilder.prototype.mapFunction = function (pair, destinationMember) {
            var typeMap = this.configurationProvider.findTypeMapFor(pair);
            if (typeMap) {
                if (!typeMap.hasDerivedTypesToInclude) {
                    typeMap.seal(this.configurationProvider);
                }
                return function (source, destination, context) {
                    return context.map(pair, source, destination ? destination[destinationMember] : null);
                };
            }
            throw new Error("Missing map for mapping pair " + pair.toString());
        };
        TypeMapPlanBuilder.prototype.buildValueResolver = function (memberMap /*, destValueGetter: LambdaExpression*/) {
            var resolver;
            if (memberMap.customMappingFunction) {
                resolver = function (source) { return source == null ? null : memberMap.customMappingFunction(source); };
            }
            else if (memberMap.sourceMembers.length) {
                // TODO: chain
                resolver = function (source) { return source == null ? null : source[memberMap.sourceMembers[0]]; };
            }
            else {
                throw new Error("Unable to detect source member for destination member \"" + memberMap.destinationMember.toString() + "\"");
            }
            return function (source, destination, context) {
                var value = resolver(source, destination, context);
                if (value == null && typeof memberMap.nullSubstitute !== 'undefined') {
                    if (typeof memberMap.nullSubstitute === 'function') {
                        return memberMap.nullSubstitute(source);
                    }
                    return memberMap.nullSubstitute;
                }
                return value == null ? null : value;
            };
        };
        return TypeMapPlanBuilder;
    }());

    var TypeMap = /** @class */ (function () {
        function TypeMap(types, profile) {
            this.types = types;
            this.profile = profile;
            this.sourceType = this.types.source;
            this.destinationType = this.types.destination;
            this._propertyMaps = new Map();
            this._valueTransformers = [];
            this._includedBaseTypes = new Set();
            this._includedDerivedTypes = new Set();
            this._inheritedTypeMaps = new Set();
            this._beforeMapFunctions = new Set();
            this._afterMapFunctions = new Set();
            this._sourceMemberConfigs = new Map();
            this._subtypeMaps = [];
            this.sealed = false;
        }
        Object.defineProperty(TypeMap.prototype, "propertyMaps", {
            get: function () { return this._propertyMaps; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "subtypeMaps", {
            get: function () { return this._subtypeMaps; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "mapFunction", {
            get: function () { return this._mapFunction; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "valueTransformers", {
            get: function () { return this._valueTransformers; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "beforeMapFunctions", {
            get: function () { return this._beforeMapFunctions; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "afterMapFunctions", {
            get: function () { return this._afterMapFunctions; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "includedBaseTypes", {
            get: function () { return this._includedBaseTypes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "includedDerivedTypes", {
            get: function () { return this._includedDerivedTypes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "hasDerivedTypesToInclude", {
            get: function () {
                return this._includedDerivedTypes.size > 0 || this.destinationTypeOverride != null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeMap.prototype, "sourceMemberConfigs", {
            get: function () { return this._sourceMemberConfigs; },
            enumerable: true,
            configurable: true
        });
        TypeMap.prototype.addValueTransformation = function (transformer) {
            this._valueTransformers.push(transformer);
        };
        TypeMap.prototype.includeBasePair = function (basePair) {
            if (this.types === basePair) {
                throw new Error('You cannot include a type map into itself.');
            }
            this._includedBaseTypes.add(basePair);
        };
        TypeMap.prototype.includeDerivedPair = function (derivedPair) {
            if (this.types === derivedPair) {
                throw new Error('You cannot include a type map into itself.');
            }
            this._includedDerivedTypes.add(derivedPair);
        };
        TypeMap.prototype.addPolymorphicMap = function (condition, pair) {
            this._subtypeMaps.push({ condition: condition, pair: pair });
        };
        TypeMap.prototype.addInheritedMap = function (inheritedTypeMap) {
            this._inheritedTypeMaps.add(inheritedTypeMap);
        };
        TypeMap.prototype.addBeforeMap = function (mapper) {
            this._beforeMapFunctions.add(mapper);
        };
        TypeMap.prototype.addAfterMap = function (mapper) {
            this._afterMapFunctions.add(mapper);
        };
        TypeMap.prototype.seal = function (configurationProvider) {
            var _this = this;
            if (this.sealed) {
                return;
            }
            this.sealed = true;
            this._inheritedTypeMaps.forEach(function (inheritedTypeMap) { return _this.applyInheritedTypeMap(inheritedTypeMap); });
            this._mapFunction = new TypeMapPlanBuilder(configurationProvider, this).createMapper();
        };
        TypeMap.prototype.findOrCreatePropertyMapFor = function (destinationProperty) {
            var propertyMap = this._propertyMaps.get(destinationProperty);
            if (propertyMap) {
                return propertyMap;
            }
            propertyMap = new PropertyMap(destinationProperty);
            this.insertPropertyMap(propertyMap);
            return propertyMap;
        };
        TypeMap.prototype.findOrCreateSourceMemberConfigFor = function (sourceMember) {
            var config = this._sourceMemberConfigs.get(sourceMember);
            if (config) {
                return config;
            }
            config = new SourceMemberConfig(sourceMember);
            this._sourceMemberConfigs.set(sourceMember, config);
            return config;
        };
        TypeMap.prototype.insertPropertyMap = function (propertyMap) {
            this._propertyMaps.set(propertyMap.destinationMember, propertyMap);
        };
        TypeMap.prototype.applyInheritedTypeMap = function (inheritedTypeMap) {
            var _a;
            var _this = this;
            inheritedTypeMap.propertyMaps.forEach(function (inheritedMappedProperty) {
                if (inheritedMappedProperty.isMapped) {
                    var conventionPropertyMap = _this._propertyMaps.get(inheritedMappedProperty.destinationMember);
                    if (conventionPropertyMap) {
                        conventionPropertyMap.applyInheritedPropertyMap(inheritedMappedProperty);
                    }
                    else {
                        _this.insertPropertyMap(new PropertyMap(inheritedMappedProperty.destinationMember, _this, inheritedMappedProperty));
                    }
                }
            });
            inheritedTypeMap._beforeMapFunctions.forEach(function (fn) { return _this._beforeMapFunctions.add(fn); });
            inheritedTypeMap._afterMapFunctions.forEach(function (fn) { return _this._afterMapFunctions.add(fn); });
            (_a = this._valueTransformers).unshift.apply(_a, inheritedTypeMap.valueTransformers);
            // apply inherited source member configs
            inheritedTypeMap._sourceMemberConfigs.forEach(function (inheritedSourceMemberConfig) {
                if (inheritedSourceMemberConfig.isIgnored()) {
                    var sourceMember = _this._sourceMemberConfigs.get(inheritedSourceMemberConfig.sourceMember);
                    if (sourceMember) {
                        sourceMember.ignore();
                    }
                    else {
                        _this._sourceMemberConfigs.set(inheritedSourceMemberConfig.sourceMember, inheritedSourceMemberConfig);
                    }
                }
            });
        };
        return TypeMap;
    }());

    var ProfileMap = /** @class */ (function () {
        function ProfileMap(profile, configuration) {
            this.typeMapConfigs = profile.typeMapConfigs;
            this.valueTransformers = profile.valueTransformers.concat(configuration ? configuration.valueTransformers : []);
        }
        ProfileMap.prototype.register = function (configurationProvider) {
            for (var _i = 0, _a = this.typeMapConfigs; _i < _a.length; _i++) {
                var config = _a[_i];
                this.buildTypeMap(configurationProvider, config);
            }
        };
        ProfileMap.prototype.configure = function (configurationProvider) {
            for (var _i = 0, _a = this.typeMapConfigs; _i < _a.length; _i++) {
                var typeMapConfig = _a[_i];
                var typeMap = configurationProvider.findTypeMapFor(typeMapConfig.types);
                this.configureTypeMap(typeMap, configurationProvider);
            }
        };
        ProfileMap.prototype.configureTypeMap = function (typeMap, configurationProvider) {
            this.applyBaseMaps(typeMap, typeMap, configurationProvider);
            this.applyDerivedMaps(typeMap, typeMap, configurationProvider);
        };
        ProfileMap.prototype.buildTypeMap = function (configurationProvider, config) {
            // TODO: factory
            var typeMap = new TypeMap(config.types, this);
            // config.types.members.forEach(member => typeMap.addPropertyMap(member));
            config.configure(typeMap);
            configurationProvider.registerTypeMap(typeMap);
        };
        ProfileMap.prototype.applyBaseMaps = function (derivedMap, currentMap, configurationProvider) {
            for (var _i = 0, _a = configurationProvider.getIncludedTypeMaps(currentMap.includedBaseTypes); _i < _a.length; _i++) {
                var baseMap = _a[_i];
                baseMap.includeDerivedPair(currentMap.types);
                derivedMap.addInheritedMap(baseMap);
                this.applyBaseMaps(derivedMap, baseMap, configurationProvider);
            }
        };
        ProfileMap.prototype.applyDerivedMaps = function (baseMap, typeMap, configurationProvider) {
            for (var _i = 0, _a = configurationProvider.getIncludedTypeMaps(typeMap.includedDerivedTypes); _i < _a.length; _i++) {
                var derivedMap = _a[_i];
                derivedMap.includeBasePair(typeMap.types);
                derivedMap.addInheritedMap(baseMap);
                this.applyDerivedMaps(baseMap, derivedMap, configurationProvider);
            }
        };
        return ProfileMap;
    }());

    var MappingExpressionBase = /** @class */ (function () {
        function MappingExpressionBase(types) {
            this.types = types;
            this.sourceType = isType(this.types.source) ? this.types.source : null;
            this.destinationType = isType(this.types.destination) ? this.types.destination : null;
            this.valueTransformers = [];
            this.memberConfigurations = [];
            this.sourceMemberConfigurations = [];
            this.typeMapActions = [];
        }
        MappingExpressionBase.prototype.configure = function (typeMap) {
            for (var _i = 0, _a = this.typeMapActions; _i < _a.length; _i++) {
                var action = _a[_i];
                action(typeMap);
            }
            for (var _b = 0, _c = this.memberConfigurations; _b < _c.length; _b++) {
                var memberConfig = _c[_b];
                memberConfig.configure(typeMap);
            }
            for (var _d = 0, _e = this.sourceMemberConfigurations; _d < _e.length; _d++) {
                var memberConfig = _e[_d];
                memberConfig.configure(typeMap);
            }
            for (var _f = 0, _g = this.valueTransformers; _f < _g.length; _f++) {
                var valueTransformer = _g[_f];
                typeMap.addValueTransformation(valueTransformer);
            }
        };
        MappingExpressionBase.prototype.addTransform = function (transformer) {
            this.valueTransformers.push(transformer);
            return this;
        };
        MappingExpressionBase.prototype.convertUsing = function (mappingFunction) {
            this.typeMapActions.push(function (tm) { return tm.customMapFunction = mappingFunction; });
        };
        MappingExpressionBase.prototype.constructUsing = function (mappingFunction) {
            this.typeMapActions.push(function (tm) { return tm.customCtorFunction = mappingFunction; });
            return this;
        };
        MappingExpressionBase.prototype.includeBase = function (pair) {
            // TODO: check is derived
            this.typeMapActions.push(function (tm) { return tm.includeBasePair(pair); });
            return this;
        };
        MappingExpressionBase.prototype.include = function (pair) {
            this.typeMapActions.push(function (tm) { return tm.includeDerivedPair(pair); });
            return this;
        };
        MappingExpressionBase.prototype.mapSubtype = function (pair, discriminatorCondition) {
            this.typeMapActions.push(function (tm) { return tm.addPolymorphicMap(discriminatorCondition, pair); });
            this.include(pair);
            return this;
        };
        MappingExpressionBase.prototype.beforeMap = function (mapper) {
            this.typeMapActions.push(function (tm) { return tm.addBeforeMap(mapper); });
            return this;
        };
        MappingExpressionBase.prototype.afterMap = function (mapper) {
            this.typeMapActions.push(function (tm) { return tm.addAfterMap(mapper); });
            return this;
        };
        return MappingExpressionBase;
    }());

    var MemberConfigurationExpression = /** @class */ (function () {
        function MemberConfigurationExpression(destinationMember) {
            this.destinationMember = destinationMember;
            this.propertyMapActions = [];
        }
        MemberConfigurationExpression.prototype.configure = function (typeMap) {
            var propertyMap = typeMap.findOrCreatePropertyMapFor(this.destinationMember);
            this.apply(propertyMap);
        };
        MemberConfigurationExpression.prototype.mapFrom = function (mappingFunction) {
            this.sourceMember = mappingFunction;
            this.propertyMapActions.push(function (pm) { return pm.mapFrom(mappingFunction); });
            return this;
        };
        MemberConfigurationExpression.prototype.mapFromUsing = function (mappingFunction, pair) {
            this.propertyMapActions.push(function (pm) { return pm.mapFromUsing(mappingFunction, pair); });
            return this;
        };
        MemberConfigurationExpression.prototype.addTransform = function (transformer) {
            this.propertyMapActions.push(function (pm) { return pm.addValueTransformation(transformer); });
            return this;
        };
        MemberConfigurationExpression.prototype.condition = function (condition) {
            this.propertyMapActions.push(function (pm) { return pm.condition = condition; });
            return this;
        };
        MemberConfigurationExpression.prototype.preCondition = function (condition) {
            this.propertyMapActions.push(function (pm) { return pm.precondition = condition; });
            return this;
        };
        MemberConfigurationExpression.prototype.nullSubstitute = function (nullSubstitute) {
            this.propertyMapActions.push(function (pm) { return pm.nullSubstitute = nullSubstitute; });
            return this;
        };
        MemberConfigurationExpression.prototype.ignore = function () {
            this.propertyMapActions.push(function (pm) { return pm.ignored = true; });
        };
        MemberConfigurationExpression.prototype.auto = function () {
            var _this = this;
            this.propertyMapActions.push(function (pm) { return pm.chainMembers([_this.destinationMember]); });
            return this;
        };
        MemberConfigurationExpression.prototype.apply = function (propertyMap) {
            for (var _i = 0, _a = this.propertyMapActions; _i < _a.length; _i++) {
                var action = _a[_i];
                action(propertyMap);
            }
            // TODO: check mapped readonly
        };
        return MemberConfigurationExpression;
    }());

    var MappingExpression = /** @class */ (function (_super) {
        __extends(MappingExpression, _super);
        function MappingExpression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MappingExpression.prototype.forMember = function (destinationMember, memberOptions) {
            return this.forDestinationMember(destinationMember, memberOptions);
        };
        MappingExpression.prototype.forDestinationMember = function (destinationMember, memberOptions, auto) {
            if (auto === void 0) { auto = false; }
            var expression = new MemberConfigurationExpression(destinationMember);
            if (auto) {
                expression.auto();
            }
            this.memberConfigurations.push(expression);
            memberOptions(expression);
            return this;
        };
        return MappingExpression;
    }(MappingExpressionBase));

    var SourceMappingExpression = /** @class */ (function () {
        function SourceMappingExpression(sourceMember) {
            this.sourceMember = sourceMember;
            this.sourceMemberActions = [];
        }
        SourceMappingExpression.prototype.ignore = function () {
            this.sourceMemberActions.push(function (smc) { return smc.ignore(); });
        };
        SourceMappingExpression.prototype.configure = function (typeMap) {
            var sourceMemberConfig = typeMap.findOrCreateSourceMemberConfigFor(this.sourceMember);
            for (var _i = 0, _a = this.sourceMemberActions; _i < _a.length; _i++) {
                var action = _a[_i];
                action(sourceMemberConfig);
            }
        };
        return SourceMappingExpression;
    }());

    var AutoMappingExpression = /** @class */ (function (_super) {
        __extends(AutoMappingExpression, _super);
        function AutoMappingExpression(types) {
            var _this = _super.call(this, types) || this;
            _this.typeMapActions.push(function (tm) { return tm.implicitAutoMapping = true; });
            return _this;
        }
        AutoMappingExpression.prototype.forMember = function (destinationMember, memberOptions) {
            return this.forDestinationMember(destinationMember, memberOptions, true);
        };
        AutoMappingExpression.prototype.forSourceMember = function (sourceMember, memberOptions) {
            var config = new SourceMappingExpression(sourceMember);
            memberOptions(config);
            this.sourceMemberConfigurations.push(config);
            return this;
        };
        return AutoMappingExpression;
    }(MappingExpression));

    var Profile = /** @class */ (function () {
        function Profile() {
            this.typeMapConfigs = [];
            this.valueTransformers = [];
        }
        Profile.prototype.createAutoMap = function (pair, members) {
            return this.configureMappingExpression(new AutoMappingExpression(pair), members);
        };
        Profile.prototype.createMap = function (pair, config) {
            if (config === void 0) { config = {}; }
            return this.configureMappingExpression(new MappingExpression(pair), config);
        };
        Profile.prototype.createStrictMap = function (pair, config, allMemberConfig) {
            return this.configureMappingExpression(new MappingExpression(pair), config, allMemberConfig);
        };
        Profile.prototype.configureMappingExpression = function (expression, config, allMemberConfig) {
            for (var _i = 0, _a = Object.keys(config); _i < _a.length; _i++) {
                var member = _a[_i];
                if (allMemberConfig) {
                    expression.forMember(member, allMemberConfig);
                }
                expression.forMember(member, config[member]);
            }
            this.typeMapConfigs.push(expression);
            return expression;
        };
        return Profile;
    }());

    var MapperConfigurationExpression = /** @class */ (function (_super) {
        __extends(MapperConfigurationExpression, _super);
        function MapperConfigurationExpression() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._profiles = [];
            return _this;
        }
        Object.defineProperty(MapperConfigurationExpression.prototype, "profiles", {
            get: function () { return this._profiles; },
            enumerable: true,
            configurable: true
        });
        MapperConfigurationExpression.prototype.createProfile = function (profileName, configure) {
            var profile = new NamedProfile(profileName);
            configure(profile);
            this.addProfile(profile);
        };
        MapperConfigurationExpression.prototype.addProfile = function (profile) {
            this._profiles.push(profile);
        };
        return MapperConfigurationExpression;
    }(Profile));
    var NamedProfile = /** @class */ (function (_super) {
        __extends(NamedProfile, _super);
        function NamedProfile(name) {
            var _this = _super.call(this) || this;
            _this.profileName = name;
            return _this;
        }
        return NamedProfile;
    }(Profile));

    var MapperConfiguration = /** @class */ (function () {
        function MapperConfiguration(configure) {
            this.mapConfigs = [];
            this.typeMapRegistry = new Map();
            var expression = new MapperConfigurationExpression();
            configure(expression);
            var config = new ProfileMap(expression);
            this._profiles = [config].concat(expression.profiles.map(function (p) { return new ProfileMap(p, expression); }));
            this.seal();
        }
        MapperConfiguration.prototype.createMapper = function () {
            return new Mapper(this);
        };
        MapperConfiguration.prototype.registerTypeMap = function (typeMap) {
            this.typeMapRegistry.set(typeMap.types, typeMap);
        };
        MapperConfiguration.prototype.findTypeMapFor = function (pair) {
            return this.typeMapRegistry.get(pair);
        };
        MapperConfiguration.prototype.getIncludedTypeMaps = function (includedTypes) {
            var _this = this;
            return Array.from(includedTypes).map(function (pair) {
                var typeMap = _this.findTypeMapFor(pair);
                if (typeMap) {
                    return typeMap;
                }
                throw new Error('Undefined mapping pair');
            });
        };
        MapperConfiguration.prototype.getMapperFunction = function (pair) {
            var mapper = this.typeMapRegistry.get(pair);
            if (!mapper) {
                throw new Error('Unable to locate mapper for provided pair');
            }
            return mapper.mapFunction;
        };
        MapperConfiguration.prototype.seal = function () {
            var _this = this;
            for (var _i = 0, _a = this._profiles; _i < _a.length; _i++) {
                var profile = _a[_i];
                profile.register(this);
            }
            // TODO: IncludeAllDerivedTypes
            for (var _b = 0, _c = this._profiles; _b < _c.length; _b++) {
                var profile = _c[_b];
                profile.configure(this);
            }
            this.typeMapRegistry.forEach(function (typeMap) { return typeMap.seal(_this); });
        };
        MapperConfiguration.prototype.getAllTypeMaps = function () {
            return Array.from(this.typeMapRegistry.values());
        };
        return MapperConfiguration;
    }());

    exports.ArrayToObjectMappingPair = ArrayToObjectMappingPair;
    exports.Mapper = Mapper;
    exports.MapperConfiguration = MapperConfiguration;
    exports.MappingPair = MappingPair;
    exports.Profile = Profile;
    exports.isSymbol = isSymbol;
    exports.isType = isType;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=mapper.umd.js.map
