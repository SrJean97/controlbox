import { SourceMemberConfig } from './configuration/source-member-config';
import { IConfigurationProvider, MapperFunction, MappingFunction, MemberInfo, Type, ValueTransformer } from './interface';
import { PropertyMap } from './property-map';
import { MappingPair } from './mapping-pair';
import { ProfileMap } from './profile-map';
interface ISubtypeMap {
    condition: (source: any) => boolean;
    pair: MappingPair<any, any>;
}
export declare class TypeMap {
    readonly types: MappingPair<any, any>;
    readonly profile: ProfileMap;
    get propertyMaps(): ReadonlyMap<MemberInfo, PropertyMap>;
    get subtypeMaps(): ReadonlyArray<ISubtypeMap>;
    get mapFunction(): MapperFunction<any, any>;
    get valueTransformers(): ReadonlyArray<ValueTransformer>;
    get beforeMapFunctions(): ReadonlySet<MapperFunction>;
    get afterMapFunctions(): ReadonlySet<MapperFunction>;
    get includedBaseTypes(): ReadonlySet<MappingPair<any, any>>;
    get includedDerivedTypes(): ReadonlySet<MappingPair<any, any>>;
    get hasDerivedTypesToInclude(): boolean;
    get sourceMemberConfigs(): ReadonlyMap<MemberInfo, SourceMemberConfig>;
    customMapFunction: MapperFunction<any, any>;
    customCtorFunction: MappingFunction<any, any>;
    readonly sourceType: Type<any> | symbol;
    readonly destinationType: Type<any> | symbol;
    destinationTypeOverride: any;
    implicitAutoMapping: boolean;
    private readonly _propertyMaps;
    private readonly _valueTransformers;
    private readonly _includedBaseTypes;
    private readonly _includedDerivedTypes;
    private readonly _inheritedTypeMaps;
    private readonly _beforeMapFunctions;
    private readonly _afterMapFunctions;
    private readonly _sourceMemberConfigs;
    private readonly _subtypeMaps;
    private _mapFunction;
    private sealed;
    constructor(types: MappingPair<any, any>, profile: ProfileMap);
    addValueTransformation(transformer: ValueTransformer): void;
    includeBasePair(basePair: MappingPair<any, any>): void;
    includeDerivedPair(derivedPair: MappingPair<any, any>): void;
    addPolymorphicMap(condition: (source: any) => boolean, pair: MappingPair<any, any>): void;
    addInheritedMap(inheritedTypeMap: TypeMap): void;
    addBeforeMap(mapper: MapperFunction): void;
    addAfterMap(mapper: MapperFunction): void;
    seal(configurationProvider: IConfigurationProvider): void;
    findOrCreatePropertyMapFor(destinationProperty: MemberInfo): PropertyMap;
    findOrCreateSourceMemberConfigFor(sourceMember: MemberInfo): SourceMemberConfig;
    private insertPropertyMap;
    private applyInheritedTypeMap;
}
export {};
